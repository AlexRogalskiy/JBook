# java.lang.Object#finalize

## Введение

Метод `finalize()` объявлен как:

```java
protected void finalize() throws Throwable { }
```

Данный метод вызывается `Garbage Collector`(далее - просто `GC`) тогда, когда `GC` полагает, что объект более не нужен, никем не используется и его пора утилизировать.

В общем виде можно считать, что `GC` думает, что объект можно удалить, если на него не существует ссылок.
Но на самом деле все гораздо сложнее, существуют несколько стратегий поведения `GC` и все они сложнее, чем простой подсчет ссылок. Подробнее про то, как работает [GC](../other/garbage_collector.md).

Однако, сейчас мы говорим все же про `finalize`.
На первый взгляд, может показаться, что это отличный метод, в который удобно поместить закрытие ресурсов и все, что нужно освобождать/удалять при уничтожении класса.

Но это впечатление обманчиво. Более того, использование `finalize` подвержено ошибкам и многие вообще считают, что использовать его **неправильно**.

Почему?

Прежде всего потому что у нас нет **НИКАКИХ** гарантий, что этот метод вообще вызовется.
Это легко может произойти, если у нас где-то в коде есть забытая ссылка на объект: мы про ссылку ничего не знаем, но она существует и `GC` не будет удалять этот объект.
Данный метод также вызван не будет, например, если приложение будет остановлено или экстренно завершено.

Еще одним существенным камнем в огород использования `finalize()` является то, что сейчас алгоритмы сборки мусора изменились и она может происходить редко. А это значит, что большую часть времени, даже если все работает хорошо, ресурсы не будут освобождены. А представьте, что эти ресурсы - это подключения к серверу базы данных? В таком случае ваши подключения будут просто простаивать без дела и негативно влиять на производительность не только вашего приложения, но и сервера базы данных.

Важно помнить, что `GC` не вызывает `finalize()` напрямую, а добавляет объекты в список, вызывая `java.lang.ref.Finalizer.register(Object)`.

Объект класса `java.lang.ref.Finalizer` представляет собой ссылку на объект, для которого надо вызвать `finalize()`, и хранит ссылки на следующий и предыдущий `Finalizer`, формируя двусвязный список.

Вызов `finalize` происходит в отдельном потоке `java.lang.ref.Finalizer.FinalizerThread`, вызовы `finalize` идут последовательно так, как добавлялись. Поэтому, если `finalize` зависает, то зависнет именно `FinalizerThread`, если класс имеет пустой метод `finalize`, то объекты такого класса будут и дальше удаляться, если же метод не пуст, то добавляются в список и ждут, пока все не отвиснет или не упадет окончательно, либо мы вообще не завершим наше приложение.

Именно поэтому, если в `finalize` методе произойдет блокировка(например, deadlock), то `GC` не перестанет работать.

В большинстве случаев не рекомендуется переопределять и использовать метод `finalize` в качестве очистки ресурсов и т.д.

Единственный пример, где `finalize` может пригодиться - это, наверное, если вы работаете с `Weak/Soft References`, когда, например, вы работаете с объектами, которые должны после очистки что-то сделать, а `GC` такие объекты вычищает по необходимости. Но это очень специфичный случай и, возможно, даже тут лучше подумать о другом подходе, так как `finalize` оказывает влияние на производительность `GC`.

> Про типы ссылок в `Java`: // ссылка на статью про типы ссылок

## Заключение

Никогда не используйте `finalize`, предпочитая ему явную очистку ресурсов.

# Наследование

## Введение

`Наследование` — это инструмент, позволяющий описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.
Это мощный инструмент переиспользования кода и создания собственных иерархий классов.
Можно сказать, что на основе одного класса строится новый класс, путем добавления новых полей и методов.

Сперва давайте постараемся ответить на вопрос: Зачем вообще придумали `Наследование`?

Для ответа на него давайте объявим некоторый класс.

> Тут нам на помощь снова придет извечный бродяга примеров - класс Person.

```java
class Person {
  private int age;
  private String name;

  // some remaining code
}
```

Пока все прекрасно и удобно.

Но представим, что теперь понадобилось создать новый класс `Employee` - работника.

`Employee` имеет те же черты, что и `Person`, но вдобавок к этому он еще устроен на работу, получает зарплату и т.д.
Т.е это тот же `Person`, но с еще одним дополнительным полем - работа.

В мире, где механизм наследования отсутствует - мы бы объявили этот класс следующим образом:

```java
class Employee {
  private int age;
  private String name;
  private String work;

  // some remaining code
}
```

По сути, все что мы сделали - это скопировали один код класса `Person` и вставили его в `Employee`, добавив, разумеется, сверху еще щепотку нового функционала.

Не мне вам объяснять, что подобный подход - копирования и вставки - это пагубная, опасная и гневающая богов привычка.

Вдобавок к этому есть и еще один неприятный момент!

Для нас очевидно, что эти классы связаны логически, т.е `Employee` - это какой-то `Person`, устроенный на работу, но для `Java` эта связь совсем не очевидна, с точки зрения языка это просто два разных, никак не связанных и не имеющих ничего общего класса.

Но мы-то знаем, что это не так!

Возникает резонное желание - сделать так, чтобы язык знал о связи наших классов и убрать копирование кода.

Разумно, что хочется делегировать ответственность за это копирование кода и поддержание его в консистентном состоянии нашему языку программирования?

> Под консистентным состоянием я имею в виду то, что при добавлении нового поля или метода в `Person` это поле также появится и у `Employee`.

Собственно, тут на сцену и выходит `Наследование`.

## Создание иерархии классов

Для того, чтобы воспользоваться механизмом наследования, т.е унаследовать один класс от другого, в `Java` существует ключевое слово `extends`.

Класс, от которого производится наследование, называется `базовым`, `родительским` или `суперклассом`.
Новый класс называется `потомком`, `наследником`, `дочерним` или `производным` классом.

Перепишем теперь наш код с использованием `наследования`.

> Стоит заметить, что мы изменили модификаторы доступа к полям классов.
> Модификаторы доступа позволяют вам влиять на то, какие поля и методы классов будут участвовать в наследовании, а какие нет.
>
> Про модификаторы доступа нужно почитать [тут](./encapsulation.md).

```java
class Person {
  protected int age;
  protected String name;

  public Person(int age, String name) {
    this.age = age;
    this.name = name;
  }

  // some remaining code
}

class Employee extends Person {
    private String address;

    public Employee(int age, String name, String address) {
        super(age, name);
        this.address = address
    }
}
```

Теперь, мало того, что код получился более компактным, так как мы убрали дублирование, так еще и выстроилась иерархия классов.
`Person` и `Employee` уже больше не являются двумя независимыми классами, как это было в первом примере.

Для демонстрации этого мы просто создадим метод, который ждет на вход экземпляры класса `Person`.
Допустим, у нас реализована некая телефонная книга:

```java
class PhoneBook {
    public static void find(Person p) {
        System.out.println(p.name);
    }

    // some code
}
```

Запустите следующий код c классами, которы мы только что написали:

```java
public static void main(String[] args) {
    Person p = new Person(27, "Aleksandr");
    Employee e = new Employee(27, "Aleksandr", "Sberbank");

    PhoneBook.find(p);
    PhoneBook.find(e);
}
```

Благодаря тому, что `Employee` является наследником `Person` код скомпилируется, а при его выполнении вы увидите в консоли:

```java
Aleksandr
Aleksandr
```

Это возможно потому, что производный класс полностью удовлетворяет спецификации родительского, однако может иметь дополнительную функциональность.
Именно поэтому мы безболезненно в телефонную книгу можем передать и `Person`, и `Employee`.

Если же вы попробуете повторить тот же трюк, но с классами не использовавшими наследование, как в начальном варианте, код даже не скомпилируется, ведь телефонная книга ждет некоторый `Person`.
Но `Person` и `Employee` в первом варианте - это два абсолютно разных класса, которые никак не связаны друг с другом!

### Примечание

Важно понимать, что наследование - это не просто инструмент для избавления от дублирования кода.

Как мы уже обсуждали во [введении в ООП](./intro.md), класс - это совокупность `поведения` и `состояния`.

Состояние - это то, какую информацию и какие данные хранит класс.
Поведение - это то, что мы можем ожидать при работе с классом, как с ним взаимодействовать и т.д.

Помните, что наследование - это приобретение *и* состояния, *и* поведения класса-родителя.

> Наследование - это приобретение и состояния, и поведения класса-родителя.

## Ключевые слова this и super

Внимательный читатель сразу обратил внимание на еще одно новое ключевое слово в теле конструктора класса Employee - `super`.
А если вы присмотритесь еще внимательней, то вы увидите и ключевое слово `this`.

Так вот, `this` - это ссылка на объект, текущего класса, а `super` - ссылка на объект его родительского класса.
Само слово `super` пошло из теории множеств, где используется термин супермножество.

Раз у нас есть ссылка на объект текущего или родительского класса, то и доступ до полей класса может быть организован через эту ссылку.
Примеры этого вы уже неоднократно встречали:

```java
public Person(int age, String name) {
  this.age = age;
  this.name = name;
}
```

С помощью ссылки мы получили поле `age` у текущего объекта и присвоили туда значение, переданное в конструктор.
Аналогичная ситуация с полем `name`.

Ключевые слова `this` и `super` также могут быть использованы для вызова конструктора текущего или родительского класса соответственно:

```java
class Person {
  protected int age;
  protected String name;

  public Person(int age, String name) {
    this.age = age;
    this.name = name;
  }

  public Person(String name) {
    this(20, name);
  }

  // some remaining code
}
```

Здесь мы создали два конструктора класса, один из которых принимает два аргумента, а другой - только один.
В теле второго конструктора мы вызываем первый, наиболее расширенный, передавая ему значение по умолчанию `20`.

Второй конструктор по сути равносилен следующей записи:

```java
public Person(String name) {
  this.age = 20;
  this.name = name;
}
```

То же самое справедливо и для `super()`, что мы видели в примере выше:

```java
class Employee extends Person {
    private String address;

    public Employee(int age, String name, String address) {
        super(age, name);
        this.address = address
    }
}
```

Из этого кода можно сделать вывод, что если у родительского класса есть не пустой конструктор,
то при создании дочернего класса мы **обязаны** вызвать родительский конструктор, что и происходит.

Если задуматься, то это довольно логично, ведь вы строите свой дочерний класс, который базируется на родителськом.
Нельзя построить дом, не заложив фундамент.

И `this`, и `super` — это нестатические переменные, соответственно их нельзя использовать в статическом контексте.
Переменной `this` нельзя присвоить новое значение, что тоже очень даже логично.

Теперь стоит сказать о том, что в `Java` все классы неявно являются наследниками `java.lang.Object`.
А значит при создании любого класса, происходит вызов родительского конструктора через `super()`.

При этом, даже если вы не создали ни одного конструктора класса, то `Java` все равно создаст пустой конструктор по умолчанию и вызовет там `super()`.
Ведь мы создаем объект класса, родительский класс которого - `java.lang.Object`.

Если вам потребовалось внутри класса вызвать конструктор, например, более расширенный, то делать это надо именно через `this`:

```java
class Employee extends Person {
    protected String address;

    public Employee(int age, String name, String address) {
        super(age, name);
        this.address = address;
    }

    public Employee(int age, String name) {
        this(age, name, "EMPTY");
    }
}
```

Мы создали второй конструктор, внутри которого вызываем главный, с наибольшим количеством аргументов.
Этот прием используется тогда, когда вам необходимо для каких-то полей сделать значения по умолчанию.

Для закрепления:

| Ключевое слово | Описание                                               |
|----------------|--------------------------------------------------------|
| this           | Ссылка на текущий объект                               |
| super          | Ссылка на родительский объект                          |
| this()         | Вызов конструктора без аргументов                      |
| super()        | Вызов конструктора без аргументов родительского класса |

## Множественное наследование

Снова давайте начнем с вопроса: Может ли у класса быть более одного предка?

> `java.lang.Object` мы не берем в виду, так как он является родительским классом для всех.

В языках программирования типа `C++`, `Python` и т.д это возможно, такой механизм называется множественным наследованием.

В `Java` так сделать нельзя.

С одной стороны, это довольно удобно когда вы можете отнаследоваться от нескольких предков.
Однако, как показывает практика, множественное наследование — может оказаться потенциальным источник проблем и ошибок. И дело тут даже не в том, что у двух классов-предков могуть оказаться методы и переменные с одинаковыми именами - хотя это тоже довольно неприятная ситуация.

На мой взгляд, множественное наследование слишком развязывает руки разработчикам, позволяя часто не задумываться о том, что такое наследование и насколько это опасный инструмент.

В качестве примера, представим, что мы пишем класс `Tank`, описывающий боевой танк. У нашего танка есть пушка, пулемет, гусеницы и броня.
Пушка и пулемет - это тоже объекты.
И при множественном наследовании никто не запрещает нам взять и отнаследоваться от этих классов, получив при этом их функциональность.

Вы представляете весь ужас такого действия?

Наследование значит, что наш класс-наследник - это класс, который **является** - отношение `is a` - тем же, что и родитель.
У него те же свойства и параметры, он только расширяет родителя, но никак не сужает его возможности.

И в итоге при таком подходе наш Танк - это и пулемет, и пушка.
А это как раз таки в корне не верно.
Танк **содержит** и пулемет, и пушку, т.е здесь уже отношение - `has a`.

Вспомним пример из начала заметки, про телефонную книгу и ужаснемся: ведь теперь везде, где можно использовать пулемет - можно использовать и танк!
А значит и рядовой боец может взять в руки танк, что даже в патриотичных странах невозможно.

Применительно к программированию такие просчеты могут быть фатальными и разрушить всю архитектуру приложения.
Частично из-за возможности подобных ошибок в `Java` просто решили не разрешать множественное наследование.

Если вам интересно мое мнение, то я думаю, что множественное наследование не предоставляет настолько незаменимые и необходимые возможности, а потенциальных проблем, имеющих разрушительные последствия может создать более чем необходмио.

Забегая вперед, скажу, что наследование в чистом виде, как оно есть, применяется не так часто, вместо него чаще пользуются `композицией`.

Об этом мы еще поговорим подробнее.

## Применение

Выше мы разобрали пример не совсем разумного применения наследования, в связи с чем у вас должен возникнуть вопрос - когда можно использовать наследование, а когда нельзя?

И ответ на этот вопрос довольно прост.

Пусть у вас есть два класса, например, `A` и `B`. И вы думаете, что `A` должен быть родительским классом для `B`.

В таком случае задайте себе простой вопрос: отвечает ли `B` отношению `is a` по отношению к `A`?

Если потенциальный потомок, удовлетворяет отношению `is a` к потенциальному родителю - т.е можно сказать, что он `является` тем же, что и родительский класс, то вы можете использовать наследование.

Если на вопрос "является ли он тем же, что и родитель" ответ отрицательный - то в таком случае использовать наследование не логично.

Следующий вопрос, который вы должны задать `B` будет уже: отвечает ли `B` отношению `has a` по отношению к `A`?

Скорее всего ответ будет `да` и тогда правильнее использовать **композицию**.

> Если же ответ на оба вопроса `нет`, то вы скорее всего что-то делаете не так и строите странную абстракцию.

Для примера возьмем два класса - `Figure` и `Rectangle`.

Является ли прямоуголник некоей абстрактной фигурой? Скорее всего да.
Значит, логично сделать так, что `Rectangle` является наследником `Figure`.

В примере с танком и пушкой/пулеметом вы придете к отношению `has a`.

И раз мы к нему пришли, то давайте о нем и поговорим?

### Отношение has a

Существует несколько видов взаимодействия объектов, объединенных под общим понятием "Has-A Relationship" или "Part Of Relationship".
Это отношение означает, что один объект является составной частью другого объекта.

Существует два подвида этого отношения: если один объект создает другой объект и время жизни составляющего объекта зависит от времени жизни целого, то это называется `композиция`.
Если же один объект получает ссылку на другой объект в процессе конструирования, то это уже  `агрегация`.

В обоих случаях мы буквально составляем наш класс по кирпичикам.
Именно так, как какой-нибудь прибор состоит из деталей.

Мы не тащим за собой все из родительского объекта, а работаем только с составными частями.
Т.е это расширение функционала класса за счет **внедрения** других объектов.

#### Отличия композиции от агрегации

* Композиция

  Композиция - это такой случай, когда составные части класса **не могут** существовать без
  существования класса, в который они входят.

  Это как сердце и человек, сердце - это часть человека, но отдельно от него оно не может
  существовать, не может или его существоание не имеет смысла.

* Агрегация

  Агрегация - это такой случай, когда составные части класса **могут** существовать без
  существования класса, в который они входят.

  Это как колеса и машина, колеса - это часть машины, но они вполне могут существовать без
  конкретного текущего автомобиля, мы можем заменить их на зимние или вообще продать.

Композиция - это частный случай агрегации.

> Часто для простоты говорят просто композиция, не делая различий с агрегацией.

Давайте теперь разберем минусы и плюсы каждого из подходов: композиции/агрегации и наследования?

### Минусы и плюсы подходов

#### Отношение is a

Плюсы:

* Повторное использование уже существующих и протестированных участков кода.
* Выстраиваемая иерархия наследников.

Минусы:

* Дочерний класс зависит от изменений в родительском классе, изменив что-то в родительском - мы автоматически получаем эти изменения в дочернем.

  Пусть у нас есть своя какая-то `MyHashMap` и мы отнаследовали ее от `HashMap`, переопределили метод `add(...)`,
  если разработчики `HashMap` введут `addAll(..)` - у нас будет в этом месте дыра, ведь мы переопределили уже `add` по-своему, но не `addAll`, который будет добавлять элементы 'по старому'.

* Ошибка в неверной иерархии наследования ведет к большим проблемам с использованием нашего кода в дальнейшем.
* Нарушение инкапсуляции.
* Тянем все проблемы и ошибки наследованного кода.
* Тяжело выстраивать правильные абстракции.

Еще одним существенным минусом является следующая ситуация: это может быть причиной сильного связывания вашего кода.
При появлении большого колиечества наследников внесение правок в родительский класс не так легко и безопасно.

Для иллюстрации этого приведем следующий пример.

##### Ситуация с Бонни: MyHashMap

Почему при композиции мы избегаем ситуации описанной в примере с `MyHashMap`?

Ответ прост - при композиции мы просто создадим `HashMap` полем класса и сами пропишем интерфейс нашего класса, вызывая лишь те методы, которые нам нужны.
При этом ситуаций, которые описаны выше, просто не возникнет - мы определим метод `add`, как нам надо и даже если разработчики добавят в `HashMap` какой-то
свой еще один `addAll` метод - нас это никак не затронет, так как наш класс умеет только то, что мы прописали - и не более.

Т.е при композиции мы максимально контролируем и знаем поведение нашего класса - ведь мы сами его и написали.
Никакие "новые" методы не могут попасть в интерфейс нашего класса - пока мы сами их явно не вызовем и не напишем на них свои обертки.

При `наследовании` же, как было сказано, мы получаем любые изменения родительского класса в дочернем, более того, мы можем даже не заметить, что у нас изменился интерфейс - если он просто расширился и не сломал старый!

В какой-то мере при использовании `наследования` мы *не полностью контролируем* интерфейс нашего класса, а это может привести к трудно уловимым и раздражающим ошибкам.

#### Композиция/Агрегация

Плюсы:

* Ситуации на подобие той, что описана выше с `MyHashMap` исключены.
* Возможность скрыть проблемы класса-родителя, создав обертку, в которой скроем недостатки `API` класс-родителя.
* Легко применять и строить абстракции.

Минусы:

* Иногда действительно неудобно работать с наследованием и иерархией классов.
* Если объектов-владельцев достаточно много, то создание и уничтожение вместо одного объекта двух или более может пагубно сказаться на производтельнсоти.

`Наследование` - это именно `расширение` какого-то функционала, в то время как `композиция` - это включение(внедрение) функционала.

Существует даже правило:

> Предпочитайте композицию наследованию

## Заключение

Наследование - это очень мощный инструмент, позволяющий выстраивать иерархии классов, использовать переиспользование кода и бороться с дублированием.

Однако насколько этот инструмент мощный, настолько же и опасный.

Старайтесь не злоупотреблять наследованием!
Помните, что вы можете разрушить все абстракции и превратить ваш красивый код в тыкву.

Чаще задавайтесь вопросом: каким отношением связаны ваши классы?

Если это отношение `is a`, то это верный признак того, что здесь будет уместно использование наследования.
Если же ваше отношение - это `has a`, то постарайтесь применить агрегацию/композицию.

Всегда старайтесь избегать дублирования кода и задумывайтесь о полученной иерархии классов.

Также стоит ознакомиться с [SOLID](./SOLID.md)

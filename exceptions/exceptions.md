# Исключения

## Введение

При работе приложения зачастую возникают нестандартные ситуации и ошибки.

Например:

* Обрыв связи с БД.
* Пользователь ввел некорректыне данные.
* Не можем закрыть файл.
* Не хватает памяти.
* Делим на ноль.
* Хотим взять элемент из списка по несуществующему индексу.

Примеров тысячи.

Такие ситуации можно либо игнорировать, либо как-то реагировать на них.

Я думаю, все согласны, что игнорирование подобных ситуаций - это путь в ад, где ваше приложение работает нестабильно, некорректно, а иногда и вовсе непредсказуемо.

Поэтому на такие ситуации надо как-то реагировать.

Самая простая реакция - это возвращать некоторый код ошибки, какое-то число.

Например, 0 - это код удачного завершения приложения.
Мы получаем код возврата и уже на него реагируем.

Подобный ход имеет право на жизнь, однако, он крайне неудобен.

Во-первых, он слишком немногословен. Вы должны либо помнить что означает каждый код-возврата, либо постоянно сверятся с таблицей расшифровки, где они описаны.

Во-вторых, такой подход предоставляет не совсем удобный способ обработки возникших ошибок.

В `Java` используется другой механизм работы с такими ситуациями, который называется `exceptions` - исключения.

Так как `Java` является `ООП` языком, в котором мы в основном оперируем объектами и классами, то логично предположить, что и механизм работы `exceptions` построен на классах.

В свою очередь, объекты таких классов хранят в себе данные об ошибке или нестандартной ситуации, например, причину, сообщение и т.д.

Давайте взглянем на иерархию этих классов.

## Иерархия исключений

Ниже приведена иллюстрация исключений:

![Exception Hierarchy](../images/exceptions.png)

*Картинка большая, чтобы лучше запоминалась.*

Как вы могли заметить, корнем в этой иерархии является `java.lang.Throwable`, от которого идут два класса-наследника: `java.lang.Exception` и `java.lang.Error`.

В свою очередь `java.lang.Exception` является родительским классом для `java.lang.RuntimeException`.

В `Java` все классы являются наследниками `java.lang.Object`, `java.lang.Throwable` и компания не исключение из этого правила. Это все такие же классы, с теми же возможностями.

А раз мы работаем с классами, то мы можем с помощью наследования создать свою собственную иерархию исключений, в свои классы исключений мы также вольны добавить какие-то методы или свойства при необходимости.

Чтобы создать свой собственный `exception` вы должны отнаследоваться от одного из классов в иерархии на рисунке или от одного из их наследников.

При этом плохим тоном считается прямое наследование от `java.lang.Throwable`.

Это **строго** не рекомендуется делать, так как наследование от наиболее общего класса усложняет обработку ваших исключений. Мы поговорим о обработке исключений далее.

Вас должно было заинтересовать, что означают подписи `checked` и `unchecked` на рисунке.

### Checked и Unchecked

В `Java` исключения делятся на два типа.

Это так называемые `checked` и `unchecked`, т.е проверяемые и непроверяемые исключения.

Как мы видим по схеме, `java.lang.Throwable` и `java.lang.Exception` относятся к `checked` исключениям, в то время как `java.lang.RuntimeException` и `java.lang.Error` принадлежат к `unchecked` исключениям.

> Такое разделение существует только в `Java`, в других языках программирования, таких  как `Scala`, `Groovy` или `Python`, все исключения непроверяемые.

В чем же смысл разделения на проверяемые и непроверяемые исключения?

Все дело в том, что существует так называемый `Runtime` и `Compile time`.
`Сompile Time` - это все, что происходит во время компиляции, в то время как `Runtime` это уже непосредственно время выполнения вашего приложения.

Так вот проверяемые исключения - это искючения, которые проверяются на этапе компиляции, мы **обязаны** на них отреагировать.

Непроверяемые исключения - это исключения времени выполнения, т.е. те, которые возникают прямо во время выполнения приложения. Мы можем, но **не обязаны** на них реагировать.

Почему в `Java` ввели подобное разграничение я точно не знаю, но думаю причина в том, что разработчики решили заложить в архитектуру языка обязательность проверки наиболее распространенных исключений.

Например, отсутствие файла, с которым вы хотите работать, ошибки ввода/вывода и т.д.

С `compile time` и `runtime` ошибками разобрались, теперь давайте более подробно взглянем на иерархию исключений и попробуем понять когда какое использовать.

## Определение

Давайте попробуем определить для чего введен тот или иной тип исключения.

Каждый тип исключения охватывает свою область ошибок.

* `java.lang.Exception`

    Это ситуации, которые нам не подконтрольны.

    Например, мы не смогли закрыть файл или не смогли дессериализовать класс.
    Это `checked` исключения, они встречаются часто и мы **обязаны** на такие исключения реагировать.

* `java.lang.RuntimeException`

    Это ситуации, когда основной причиной ошибки является сам разработчик.

    Например, мы обращаемся к ссылке, содержащей `null`, делим на ноль, вышли за длину массива/списка и т.д.
    Это `unchecked` исключения, мы можем их не обрабатывать.

* `java.lang.Error`

    Это критические ошибки, после которых мы можем с трудом или вообще не в состоянии продолжить работу.
    Например, заканчивается память, переполнился стек вызовов и т.д.

    Это `unchecked` исключения, мы можем их не обрабатывать.
    Реагировать на подобные ошибки можно только в том случае, если мы можем или знаем как нам поступить в таких ситуациях. Чаще всего мы не в состоянии правильно отреагировать на подобные ошибки и реагируют на них редко.

Представьте, что вы едете по дороге, так вот предупредительные знаки - это `java.lang.Exception`-ы. Например, знак "Осторожно, дети!" говорит о том, что рядом школа и дорогу может перебежать ребенок. Вы обязаны отреагировать на это, не обязательно что-то произойдет и вы встретите ребенка, но это возможно.

А вот `java.lang.RuntimeException` - это, что называется, "shit happens".
Вы в любой момент можете попасть в неприятности.

Поэтому реагировать на `java.lang.RuntimeException`-ы вы должны только там, где вы предполагаете опасность и не хотите проблем, вы знаете как реагировать на них.

В чем же разница между `Error` и `Exception`?

### Error и Exception

`Error` - это более серьезная ситуация, нежели `Exception`.

Это серьезные проблемы в работе приложения, которые тяжело исправить, либо мы вообще не можем сделать это сейчас.

Это непросто исключительная ситуация - это ситуация, в которой работоспособность всего приложения под угрозой!

Однако, если мы не можем закрыть файл, мы делаем запрос к БД или не можем строку преобразовать к числу, то это ситуации, после которых мы **можем продолжить** работать.

Это неприятно, что вы не смогли найти или открыть файл, но не настолько критично, как переполнение стека.

Такие ситуации мы можем обработать и в таком случае стоит использовать `java.lang.Exception` или `java.lang.RuntimeException`.

Т.е разница - в *логическом разделении*.

Еще раз, если мы можем продолжить работу после ошибки используйте `Exception`. Если нет или мы не знаем как - это `Error`.

Мы много раз уже сказали про то, что можно перехватывать исключения и реагировать на них, но все еще не рассмотрели как именно это делается.

Исправим этот недостаток.

## Работа с исключениями

При работе с исключениями надо помнить простое правило:

На исключения надо либо **реагировать**, либо **делегировать**, но ни в коем случае не **игнорировать**.

Определить когда надо реагировать, а когда делегировать проще простого, просто задайте вопрос себе: "Я знаю что делать, как отреагировать на это исключение?".

Если ответ - да, то надо реагировать, если вы не знаете что делать с этим исключением, то просто прокидывайте его дальще, т.е **делегируйте**.

Для начала разберемся как **реагировать** на исключения.

### Реагирование

Недаром корнем иерархии является класс с названием `Throwable`, т.е бросаемое.

А раз исключения бросаются, то для обработки мы будем ловить их!

В `Java` исключения ловят и обрабатывают с помощью конструкции `try/catch/finally`.

На первый взгляд все просто.

Все, что **может** кинуть ошибку оборачивается в `try` блок, в блоках `catch` перечисляются все исключения, которые мы ловим. В блоке `finally` выполняется код, который будет выполнен по заврешению `try/catch`.

```java
public class ExceptionHandling {
    public static void main(String[] args) {
        try {
             // some code
        } catch(FileNotFoundException e) {
            // 1
        } catch(RuntimeException e) {
            // 2
        } finally {
            System.out.println("Hello from finally block.");
        }
    }
}
```

Если в блоке `try` у нас кинется `FileNotFoundException`, то мы попадем в `catch` блок 1, который ответственный за обработку этого исключения, если будет `RuntimeException`, то попадем в блок 2.

При этом у вас есть ссылка на объект исключения - это `e`. Поэтому вы можете его залоггировать, прокинуть дальше и т.д.

Блок `finally` назван так не просто так - мы попадем в него **всегда**.
При любом раскладе мы зайдем в `finally` блок.

---

**Вопрос**:

Мы попадем в `finally` блок даже тогда, когда в `try` стоит `return`?

```java
public class ExceptionHandling {
  public static void main(String[] args) {
    try {
         return;
    } finally {
         System.out.println("Hello from finally block");
    }
  }
}
```

Что будет выведено на экран? Или вообще ничего?

**Ответ**:

Мы попадаем в `finally` блок **всегда**!

Будет выведено: `Hello from finally block`.

---

Далее приведем несколько примеров перехвата исключений разных видов:

Ловим `java.lang.RuntimeException`:

```java
try {
   String numberAsString = "one";
   Double res = Double.valueOf(numberAsString);
    } catch (RuntimeException re) {
            System.err.println("Error while convert string to double!");
    }
```

Будет выведено на экран: `Error while convert string to double!`.

Ловим `java.lang.Error`:

```java
        try {
            throw new Error();
        } catch (RuntimeException re) {
            System.out.println("RuntimeException");
        } catch (Error error) {
            System.out.println("ERROR");
        }
    }
```

Будет выведено на экран: `ERROR`.

При этом помните, что то, что вы указываете в `catch` блоке - это как фильтр.
Фильтр, который перехватывает все исключения того типа, что вы указали и всех его потомков, расположенных ниже по иерархии.

#### Транзакционность

Еще одним важным моментом, о котором нельзя не поговорить, является то, что `try/catch/finally` блок **не транзакционный**.

Что это значит?

Под термином `транзакционность` я имею в виду то, что либо действия будут выполнены целиком и успешно, либо не будут выполнены вовсе.

Так вот `try/catch/finally` не транзакционен.

Это значит, что при возникновении исключения в `try` блоке все совершенные действия **не** откатываются к изначальному состоянию, а так и остаются совершенными.

Все выделенные ресурсы так и остаются занятыми, в том числе и при возникновении исключения.

По сути именно поэтому и существует `finally`-блок, так как туда, как уже было сказано выше, мы зайдем **в любом** случае, то там и освобождают выделенные ресурсы.

Также мы не можем работать с объектами из `try` блока в других блоках:

```java
public class ExceptionExample {
    public static void main(String[] args) {
        try {
            String line = "hello";
        } catch (Exception e) {
            System.err.println(e);
        }

        // Compile error
        System.out.println(line); // Cannot resolve symbol `line`
    }
}
```

Как вы думаете, почему?

Потому что компилятор не может нам гарантировать, что объекты, объявленные в `try`-блоке, были созданы!

Ведь могло возникнуть исключение. Тогда после места, где выбросилось исключение, оставшиеся действия не будут выполнены, а значит возможна ситуация, когда объект не будет создан, а следовательно и работать с ним нельзя.

### Реагирование через re-throw

Часто бывает необходимо перехватить исключение, залогировать его или как-то отписаться, что случилось и прокинуть его дальше, чтобы на него реагировал вызывающий код, а не мы.

Такой подход называется `re-throw`.

Мы перехватываем исключение в `catch` блоке, совершаем какие-то действия, например, логируем, после чего мы прокидываем это же(а возможно новое, с указанием причины пойманным исключением) дальше.

Как это выглядит на практике:

```java
try {
    Reader readerConf = ....
    readerConf.readConfig();
} catch(IOException ex) {
    System.err.println("Log exception: " + ex);
    throw new ConfigComponentException(ex);
}
```

Мы перехватили исключение чтения конфига - `IOException`, залогировали, обернули это исключение в новое, с более понятным названием, более узко направленное, установили причиной перехваченное `ex` и бросили дальше.

Для чего мы так сделали?

Это бывает полезно для более гибкой обработки исключений.

В примере выше парсинг конфига выкидывает слишком общее исключение, так как `IOException` это целый пласт исключений, но у нас одна проблема сейчас - мы не можем работать с этим конфигом.

Значит и сообщить об этом лучше именно как о том, что у нас не просто какой-то `IOException`, а именно `ConfigComponentException`.

При этом, так как мы вложили перехваченное исключение в новое, в `stacktrace` будет развернуто написано что и где произошло.

Замечу, что мы могли бы еще добавить какое-то текстовое описание к нашему `ConfigComponentException`, более подробно описывающее произошедшую ситуацию.

Еще одной областью применения `re-throw` бывает то, что бывает полезно перехватить `checked` исключение, залогировать его и далее прокинуть уже `unchecked`.

В `Java 8` даже существует специальное исключение `java.io.UncheckedIOException`, которое предназначено как раз для того, чтобы обернуть `IOException` в `unchecked` обертку.

### Делегирование

Помимо того, что вы можете отреагировать на исключение, вы также можете делегировать его далее, в место вызова кода, сгенерировавшего исключение.

Делегирование исключения производится с помощью ключевого слова `throws`, которое добавляется к описанию метода.

```java
String readLine(String path) throws IOException {
    BufferedReader br = new BufferedReader(...);
    String line = br.readLine();

    return line;
}
```

> Код написан только для ознакомительной цели, не стоит с него брать пример!

Таким образом вы сообщаете, что этот метод может стать местом, откуда бросится исключение и то, **как** на него реагировать уже становится заботой вызывающего этот метод.

Так как с помощью `throws` мы делегируем реакцию на исключение вызывающему коду, то `Java` позволит вам не обрабатывать указанные в `throws` исключения внутри метода.

Разумеется, можно указывать в `trhows` и `checked`, и `unchecked` исключения.

Однако `unchecked` указывать смысла особого нет, так как на то оно и непроверяемое, такие исключения не контролируются в `compile time`.

Механизм `throws` введен для проброса проверяемых исключений.

### Try-with-resources или TWR

Как уже говорилось выше про `finally` блок: код в нем выполняется в любом случае, там в основном и происходит какая-то логика по освобождению ресурсов.

Однако каждый раз писать освобождение ресурса крайне накладно.
Каждый раз при работе с файлом вы будете писать что-то типа:

```java
try {
    // code
} finally {
    resource.close();
}
```

Освобождение ресурса(например, закрытие дескриптора файла) - это поведение.
> А за поведение у нас отвечают [интерфейсы](../oop/interface.md).

Так вот было бы гораздо удобнее, если бы был бы некий общий интерфейс, который бы наследовали все классы, для которых нужно 'закрытие' в `finally` блоке и еще удобнее было бы, чтобы нам этот `finally` блок не нужно было бы писать!

Поэтому, начиная с `Java 7`, была введена конструкция `try-with-resources` или `TWR`.

Ввели специальный интерфейс `java.lang.AutoCloseable`, который имеет один метод:

```java
void close() throws Exception;
```

Все классы, которые вы хотите использовать так, как мы описали выше, должны реализовать или `java.lang.Closable`, или `java.lang.AutoCloseable` и реализовать `close`-метод у себя.

В таком случае, по выходу из `try` блока `Java` автоматически вызовет этот метод.

В качестве примера, давайте представим, что мы работаем с файлом и напишем две реализации одной задачи: используя и не используя `try-with-resources`.

Без использования `TWR`(этот код плох и служит только для примера объема необходимого кода):

```java
BufferedReader br = null;
try {
       br = new BufferedReader(new FileReader(path));
       // read from file
   } catch (IOException e) {
       // catch and do smth
   } finally {
           try {
                  if (br != null) {
                     br.close();
                  }
               } catch (IOException ex) {
                     // catch and do smth
               }
   }
```

Т.е мы создали ссылку на `BufferedReader`, попытались присвоить в `try` уже объект `BufferedReader`-а, далее делаем какую-то работу с ним, в `catch` отловили возможные ошибки и в `finally` освобождаем все занятые ресурсы.

А теперь то же самое, но в `Java 7+`:

```java
try (BufferedReader br = new BufferedReader(new FileReader(path))) {
         // read from file
} catch (IOException e) {
         // catch and do smth
}
```

И все!

Если вы пишите на `Java 7+` я рекомендую вам использовать именно такой подход.

Однако помните, что , без реализации `java.lang.Closable` или `java.lang.AutoCloseable` ваш класс не будет работать с `try-with-resources`.

---

**Вопрос**:

Получается, что используя `TWR` мы не пишем закрытие код для закрытия ресурсов, но при их закрытии может же тоже быть исключение! Что произойдет?

**Ответ**:

Точно также, как и без `TWR`, исключение выбросится так, будто оно было в `finally`-блоке.

Помните, что `TWR`, грубо говоря, просто добавляет вам блок кода вида:

```java
finally {
    resource.close();
}
```

---

### Расположение catch блоков

Как вы думаете, важен ли порядок расположения `catch` блоков при обработке исключений?

Рассмотрим ситуацию, когда некоторый используемый нами метод может выбросить два разных исключения:

```java
void method() throws Exception {
    if (new Random((System.currentTimeMillis())).nextBoolean()) {
        throw new Exception();
    } else {
       throw new IOException();
    }
}
```

> Конструкция new Random((System.currentTimeMillis())).nextBoolean() генерирует нам случайное значение false или true.

Используя этот метод нам надо отреагировать на обе ситуации, на оба исключения.

Для этого мы пишем код вроде этого:

```java
try {
  method();
} catch (Exception e) {
  // do some logic 1
} catch (IOException e) {
  // do some logic 2
}
```

Запускаем и убеждаемся, что обработка `IOException` в данном случае недостижима.

Почему?

Представьте себе как раньше добывали золото.

Грунт смешивали с водой и прогоняли через несколько фильтров, какие-то были более узкие, какие-то более широкие.

Так вот золотинка, которую мы ищем, это и есть наше исключение, а каждый фильтр - это  `catch` блок.

Если вы установили первым фильтр `ловить все, что является Exception и его потомков`, то до фильтра `ловить все, что является IOException и его потомков` мы просто не дойдем, так как верхний фильтр уже перехватит все золотинки.

Вы должны грамотно выстраивать вашу систему филльтрации и того, что мы продемонстрировали выше.

А что если у нас на два разных исключения предусмотрена одна и та же реакция? Писать два одинаковых `catch` блока не очень хочется, а учитывая, что дублирование кода - это зло, то в `Java` вы можете объединить два `catch` блока с помощью `|`:

```java
try {
    method2();
} catch (IllegalArgumentException | IndexOutOfBoundsException e) {
    // do smth
}
```

---

**Вопрос**:

Есть ли способ перехватить **все** исключения? Все возможное?

**Ответ**:

Есть! Если взглянуть еще раз на иерархию, то можно отметить, что `java.lang.Throwable` является родительским классом для всех исключений, а значит, чтобы поймать все необходимо написать что-то в виде:

```java
try {
  method();
} catch (Throwable t) {
  // catch all
}
```

Однако, делать так **не рекомендуется**.

---

**Вопрос**:

Почему ловить `java.lang.Throwable` плохо?

**Ответ**:

Дело в том, что написав

```java
try {
  method();
} catch (Throwable t) {
  // catch all
}
```

Вы будете перехватывать абсолютно все: и `java.lang.Exception`, и `java.lang.RuntimeException`, и `java.lang.Error`, и все проиводные от них.

И как реагировать на **все**? При этом учтите, что на большинство `java.lang.Error` исключений вообще не ясно как реагировать в 99% случаев. А значит, мы можем неверно отреагировать на исключение и вообще потерять данные.

Поэтому перехватывать все исключения - плохая практика.

---

**Вопрос-Тест**:

Что будет выведено на экран при запуске данного куска кода?

```java
public static void main(String[] args) {
        try {
            try {
                throw new Exception("0");
            } finally {
                if (true) {
                    throw new IOException("1");
                }

                System.err.println("2");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("3");
            System.err.println(ex.getMessage());
        }
    }
```

**Ответ**:

При выполнении данного кода выведется "1".

Почему?

Мы кидаем исключение во вложенном `try` блоке: `throw new Exception("0");`.

После этого поток программы ломается и мы попадаем в `finally` блок:

```java
if (true) {
    throw new IOException("1");
}

System.err.println("2");
```

Здесь мы гарантированно зайдем в `if` и кинем уже новое исключение: `throw new IOException("1");`.

> При этом вся информация о прошлом будет потеряна! Ведь мы никак не отреагировали на него, а в `finally` блоке и вовсе 'перезатерли' новым исключением.

На `try`, оборачивающий наш код, настроено два фильтра: первый на `IOException`, второй на `Exception`.

Так как порядок расположения задан так, что мы прежде всего смотрим на `IOException`, то и сработает этот фильтр, который выполнит следующий код:

```java
System.err.println(ex.getMessage());
```

Именно поэтому выведется `1`.

---

## Собственные исключения

Так как исключения - это те же классы и объекты, то часто бывает выстроить свою иерархию исключений, заточенных под конкретную задачу.

Например, у нас есть некоторый `method()` и он кидает три разных `Exception`-а на три разных ситуации.

Как все три ситуации обработать? В данном случае - никак.

У нас будет только один `catch` блок с перехватом `Exception`, где мы как-то должны были понимать что мы за исключение вообще перехватили и как на него реагировать.

Но создав свою собственную иерархию исключений ситуация разительным образом меняется.

Мы просто напишем три `catch` блока на каждое наше исключение в иерархии и обработаем каждую ситуацию так, как надо нам.

---

**Вопрос**:

Можно ли мне отнаследоваться от `java.lang.Throwable`?

**Ответ**:

Можно!

Однако, делать так **не рекомендуется**.

В частности, потому что ловить `java.lang.Throwable` является признаком плохого тона.

Это правило.

В вашей иерархии исключений используйте в основном `java.lang.RuntimeException` и `java.lang.Exception`.

---

## Исключения и статические блоки

Еще интересно поговорить про то, что происходит, если исключение возникает в статическом блоке.

Так вот, такие исключения оборачиваются в `java.lang.ExceptionInInitializerError`:

```java
public class ExceptionHandling {
    static {
        throwRuntimeException();
    }

    private static void throwRuntimeException()  {
        throw new NullPointerException();
    }

    public static void main(String[] args)  {
        System.out.println("Hello World");
    }
}
```

Результатом будет падение со следующим стектрейсом:

```java

java.lang.ExceptionInInitializerError Caused by: java.lang.NullPointerException at exception.test.ExceptionHandling.throwRuntimeException(ExceptionHandling.java:13) at exception.test.ExceptionHandling. (ExceptionHandling.java:8)
```

##### Исключения и наследование
//todo

Переопределяющий метод не должен бросать новое или более широкое исключение, однако он может ВООБЩЕ не бросать исключение!

## Многопоточность и исключения

Наши программы могут исполняться в нескольких потоках.

Что будет, если исключение возникнет в отдельном потоке исполнения?

Например:

```java
public class ExceptionHandling4 {
  public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread() {
        @Override
        public void run() {
                throw new RuntimeException("Testing unhandled exception processing.");
         }
    };
    t.start();
  }
}
```

Наше исключение прервет поток исполнения(interrupt thread):

```java
Exception in thread “Thread-0” java.lang.RuntimeException: Testing unhandled exception processing. at exception.test. ExceptionHandling4$1.run(ExceptionHandling4.java:27)
```

Что делать в таких ситуациях и как обрабатывать исключения?

Необходимо использовать `Thread.UncaughtExceptionHandler`.
Т.е вешать отдельный `handler` на поток, который будет обрабатывать возникшие в нем исключения.

```java
t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
          public void uncaughtException(Thread t, Throwable e)   {
             System.out.println("Handled uncaught exception in thread :" + t + " Exception : " + e);
         }
  });
```

И вывод уже будет:

```java
Handled uncaught exception in thread :Thread[Thread-0,5,main] Exception : java.lang.RuntimeException: Testing unhandled exception processing.
```

## Заключение

Механизм исключений сложен, но крайне важен для понимания.

Прежде всего, необходимо четко представлять себе иерархию исключений, так как отталкиваясь от нее вы будете настраивать свои фильтры.

Помните, что исключения делятся на два вида: `unchecked` и `checked`.

Проверяемые исключения - это искючения, которые проверяются на этапе компиляции, мы **обязаны** на них отреагировать.

Важно всегда держать в уме то, что `try`-блок **не транзакционный** - все объекты, которые создали в `try` **ДО** исключения остаются в памяти. Их надо освобождать и очищать вручную.

Если вы используете `Java` версии 7 и выше, то отдавайте предпочтение конструкции `TWR` - `try with resources`.

Помните главное: на исключения можно реагировать, их обработку можно делегировать, но ни в коем случае нельзя их игнорировать.

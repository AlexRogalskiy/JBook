# Исключения

* [Исключения](#Исключения)
  * [Введение](#Введение)
  * [Иерархия исключений](#Иерархия-исключений)
    * [Проверяемыые и непроверяемые исключения](#Проверяемыые-и-непроверяемые)
    * [Иерархия](#Иерархия)
      * [Классификация](#Классификация)
      * [Error и Exception](#error-и-exception)
  * [Работа с исключениями](#Работа-с-исключениями)
    * [Обработка исключений](#Обработка-исключений)
      * [Правила try/catch/finally](#Правила-try/catch/finally)
      * [Расположение catch блоков](#Расположение-catch-блоков)
      * [Транзакционность](#Транзакционность)
    * [Делегирование](#Делегирование)
    * [Методы и практики обработки исключительных ситуаций](#Методы-и-практики-обработки-исключительных-ситуаций)
      * [Собственные исключения](#Собственные-исключения)
      * [Реагирование через re-throw](#Реагирование-через-re-throw)
        * [Исключения при переопределении метода](#Исключения-при-переопределении-метода)
      * [Чего нельзя делать при обработке исключений](#Чего-нельзя-делать-при-обработке-исключений)
    * [Try-with-resources или try-с-ресурсами](#Try-with-resources-или-try-с-ресурсами)
  * [Исключения и статические блоки](#Исключения-и-статические-блоки)
  * [Заключение](#Заключение)
  * [Полезные ссылки](#Полезные-ссылки)

## Введение

Предположим, вам понадобилась программа, которая считывала бы содержимое файла и выводила его на экран.
В целом, здесь нет ничего сложного и код, выполняющий поставленную задачу, мог бы выглядеть как-то так:

```java
    public List<String> readAll(String path) {
        BufferedReader br = new BufferedReader(new FileReader(path));
        String line;
        List<String> lines = new ArrayList<>();
        while ((line = br.readLine()) != null) {
            lines.add(line);
        }
        
        return lines;
    }
```

И это был бы вполне рабочий вариант, если бы не одно но: мы живем не в идеальном мире. Код, приведенный выше, расчитан на то, что все не просто работает идеально, а еще и на то, что путь до файла указан верный, файл можно прочитать и еще огромное количество предположений.

Однако, как показывает практика, мир не идеален, а нас повсюду преследуют ошибки и проблемы. Кто-то может указать путь до несуществующего файла, во время чтения может произойти ошибка, например, файл поврежден или удален в процессе чтения и т.д.

Такие ситуации можно либо игнорировать, либо как-то реагировать на них.

Понятно, что игнорирование подобных ситуаций недопустимо, так как это путь к нестабильно и непредсказуемо работающему коду.
Значит, на такие ситуации надо реагировать.

Самая простая реакция - это возвращать некоторый код ошибки, некоторое число.
Например, 0 - это код удачного завершения приложения.
Мы получаем код возврата и уже на него реагируем.

Подобный ход имеет право на жизнь, однако, он крайне неудобен в повседневной разработке с ее тысячами возможных ошибок и проблемных ситуаций.
Во-первых, он слишком немногословен, так как необходимо помнить что означает каждый код-возврата, либо постоянно сверятся с таблицей расшифровки, где они описаны.
Во-вторых, такой подход предоставляет не совсем удобный способ обработки возникших ошибок. Более того, нередки ситуации, когда в месте возникновения ошибки непонятно как реагировать на возникшую проблему. В таком случае было бы удобнее делеигровать обработку ошибки вызывающему коду, до места, где будет понятно как реагировать на ошибку.

Поэтому, в `Java` используется другой механизм работы с такими ситуациями: механизм исключений.

Что такое исключение? В некотором смысле можно сказать, что исключение - это некоторое сообщение, уведомляющее о проблеме, незапланированном поведении. 
В нашем примере с чтением содержимого файла, источником такого сообщения может являться `BufferedReader` или `FileReader`. Сообщению необходим получатель/обработчик, чтобы перехватить его и что-то сделать, отреагировать.

Крайне важно понимать, что генерация исключения ломает поток выполнения программы, так как либо это сообщение будет перехвачено и обработано каким-то зарегестрированным получателем, либо программа завершится.
Представьте, что по дороге едет грузовик. То, что грузовик едет и есть потоком выполнения программы. Вдруг водитель видит, что впереди разрушенный мост - исключение, ошибка. Теперь он либо поедет по объездной дороге, т.е перехватит и отреагирует на исключение, либо остановиться и поездка будет завершена.

![Объездная](../images/exception/exception_ob.png)

Сообщения бывают разного вида, а значит и получателей может быть несколько - на каждый отдельный вид сообщения может быть своя реакция, свой обработчик.
Такое сообщение может хранить данные об ошибке или нестандартной ситуации: причину, сообщение-описание и т.д.
Исходя из описания можно сказать, что исключение - это объект некторого, специально для этого предназначенного класса. Так как проблемы и ошибки бывают разного рода, их можно классифицировать и логически разделить, значит и классы исключений можно выстроить в некоторую иерархию.

Как генерировать исключения и регистрировать обработчики мы рассмотрим позднее, а пока давайте взглянем на иерархию этих классов.

## Иерархия исключений

Ниже приведена иллюстрация исключений:

![Exception Hierarchy](../images/exception/exceptions.png)

*Картинка большая, чтобы лучше запоминалась.*

Для начала разберем загадачные подписи `checked` и `unchecked` на рисунке.

### Проверяемыые и непроверяемые

Все исключения в `Java` делятся на два типа: проверяемые и непроверяемые исключения, или, `checked` и `unchecked`.

Как мы видим по схеме, `java.lang.Throwable` и `java.lang.Exception` относятся к проверяемым исключениям, в то время как `java.lang.RuntimeException` и `java.lang.Error` - это непроверяемые исключения.

> Такое разделение существует только в `Java`, в других языках программирования, таких  как `Scala`, `Groovy` или `Python`, все исключения непроверяемые.

В чем же смысл разделения на проверяемые и непроверяемые исключения?

Так как `Java` - это компилируемый язык, то, помимо, `Runtime`, существует еще и  `Compile time`.
`Сompile Time` - это все, что происходит во время компиляции, в то время как `Runtime` это уже непосредственно работа вашего кода.

Так вот проверяемые исключения - это искючения, на которые разработчик **обязан** отреагировать, т.е написать какие-то обработчики, их наличие проверяется на этапе компиляции.
Непроверяемые исключения - это исключения времени выполнения, возникающие прямо во время выполнения приложения. Разработчик может, но **не обязан** на них реагировать.

Почему в `Java` ввели подобное разграничение? Проверяемые исключения в `Java` используются тогда, когда разработчик никак не может предотвратить их возникновение. Причину возникновения `java.lang.RuntimeException` можно проверить и устранить заранее, например, проверить ссылку на `null` перед вызовом метода, на объекте по ссылке. А вот с причинами проверяемых исключений так сделать не получится, так как ошибка при чтении файла может возникнуть непосредственно в момент чтения, потому что другая программа его удалила. Соответственно, при чтении файла требуется обрабатывать `java.lang.IOException`, который является потомком `java.lang.Exception`.

Представьте, что вы едете по дороге, так вот предупредительные знаки - это проверяемые исключения. Например, знак "Осторожно, дети!" говорит о том, что рядом школа и дорогу может перебежать ребенок. Вы обязаны отреагировать на это, не обязательно ребенок перебежит вам дорогу, но вы не можете это проконтролировать и в этом месте это наиболее вероятно.

Теперь рассмотрим непосредственно иерархию исключений.

### Иерархия

Итак, корнем иерархии является `java.lang.Throwable`, у которого два наследника: `java.lang.Exception` и `java.lang.Error`.
В свою очередь `java.lang.Exception` является родительским классом для `java.lang.RuntimeException`.

> Занятно, что класс `java.lang.Throwable` назван так, как обычно называют интерфейсы, что иногда вводит в заблуждение новичков. Однако помните, что это класс!

Так как в `Java` все классы являются наследниками `java.lang.Object`, то `java.lang.Throwable` и компания не являются исключением из этого правила. Это значит, что они имеют все стандартные методы, такие как `equals`, `hashCode`, `toString` и т.д.
Раз мы работаем с классами, то можно с помощью наследования создавать свои собственные иерархии исключений, добавляя в них какое-то поведение и состояние.
Чтобы создать свой собственный класс исключение необходимо отнаследоваться от одного из классов в иерархии исключений. При этом наследуется еще и тип исключения: проверяемое или непроверяемое.

Т.е все наследниеи `java.lang.Exception` будут проверяемыми исключениями, в то время как все наследники `java.lang.RuntimeException` будут непроверяемыми.

#### Классификация

Каждый тип исключения охватывает свою область ошибок.

* `java.lang.Exception`

    Это ситуации, которые не подконтрольны разработчику, например, не получилось закрыть файл или дессериализовать объект.
    Это проверяемые исключения, они встречаются часто и мы **обязаны** на такие исключения реагировать. Степень серьезности таких исключений варьируется от простой до умеренной.

    Пример: `java.lang.IOException`.

* `java.lang.RuntimeException`

    Это ситуации, когда основной причиной ошибки является сам разработчик, например, происходит обращение к `null` ссылке, деление на ноль, выход за границы массива и т.д.
    Это непроверяемые исключения, реагировать на них или нет решает разработчик.

    Пример: `java.lang.NullPointerException`.

* `java.lang.Error`

    Это критические ошибки, аварийные ситуации, после которых мы с трудом или вообще не в состоянии продолжить работу. Например, закончилась память, переполнился стек вызовов и т.д.

    Это непроверяемые исключения, реагировать на них или нет решает разработчик.
    Реагировать на подобные ошибки следует только в том случае, если разработчик точно знает как поступить в такой ситуациях. Перехватывать такие ошибки не рекомендуется, так как обычно разработчик не знает как реагировать на подобного рода аварийные ситуации.

Основное отличие `java.lang.Exception` от `java.lang.RuntimeException` состоит в том, что причины `java.lang.RuntimeException` можно проверить и устранить заранее.

Теперь перейдем к вопросу: в чем же разница между `java.lang.Error` и `java.lang.Exception`?

#### Error и Exception

Все просто. Исключения `java.lang.Error` - это более серьезная ситуация, нежели `java.lang.Exception`.
Это серьезные проблемы в работе приложения, которые тяжело исправить, либо вообще не ясно можно ли это сделать.

> Это непросто исключительная ситуация - это ситуация, в которой работоспособность всего приложения под угрозой!

Согласитесь, что если не получается преобразовать строку к числу, то это не та ситуация, когда все приложение должно завершаться. Это ситуация, после которой приложение **может продолжить** работать.
Да, это неприятно, что вы не смогли найти файл по указанному пути, но не настолько критично, как переполнение стека вызовов.

Т.е разница - в **логическом разделении**.

Поэтому, `java.lang.Error` используется только для критических ситуаций.

## Работа с исключениями

### Обработка исключений

Корнем иерархии является класс `java.lang.Throwable`, т.е бросаемое.
А раз исключения бросаются, то для обработки мы будем ловить их!

В `Java` исключения ловят и обрабатывают с помощью конструкции `try/catch/finally`.

При заключении кода в один или несколько блоков `try` указывается потенциальная возможность выбрасывания исключения в этом месте, все операторы, котрые могут сгенерировать исключение помещаются в этом блоке.

В блоках `catch` перечисляются исключения, на которые решено реагировать. Тут определяются блоки кода, предназначенные для решения возникших проблем. Это и есть объявление тех самых получателей/обработчиков исключений.

Тот тип исключения, что указывается в `catch` блоке можно расценивать как фильтр, который перехватывает все исключения того типа, что вы указали и всех его потомков, расположенных ниже по иерархии.

Представьте себе прииск, как в рассказах Джека Лондона. Вы, как опытный золотодобытчик, выставляете несколько фильтров, ведь вам не нужна грязь, земля и камни, вам нужно именно золото. И в нашем примере золото - это все ошибки `runtime`. Вы ставите фильтр на `java.lang.RuntimeException` и в ловите не только `java.lang.RuntimeException`, но и всех его наследников! Ведь эти потомки **тоже** `runtime` ошибки!

В блоке `finally` определяется код, который будет всегда выполнен, независимо от результата выполнения блоков `try/catch`. Этот блок будет выполняться независимо от того, выполнился или нет блок `try` до конца, было ли сгенерировано исключение или нет и было ли оно обработано в блоке `catch` или нет.

Пример:

```java
public class ExceptionHandling {
    public static void main(String[] args) {
        try {
             // some code
        } catch(FileNotFoundException fnf) {
            // обработчик 1
        } catch(RuntimeException re) {
            // обработчик 2
        } finally {
            System.out.println("Hello from finally block.");
        }
    }
}
```

В примере выше объявлен `try` блок с кодом, который потенциально может сгенерировать исключения, после `try` блока описаны два обработчика исключений, на случай генерации `FileNotFoundException` и на случай генерации любого `RuntimeException`.
Объект исключения доступен по ссылке `exception`.

#### Правила try/catch/finally

* Блок `try` находиться перед блоком `catch` или `finally`. При этом он должен иметь хотя бы один из этих блоков.
* Между `try`, `catch` и `finally` не может быть никаких операторов.
* Один блок `try` может иметь несколько `catch` блоков. В таком случае будет выполняться первый подходящий блок.
    > Поэтому сначала должны идти более специальные блоки обработки исключений, а потом уже более общие.
* Блок `finally` будет выполнен всегда, кроме случая, когда `JVM` преждевременно завершит работу или будет сгенерировано исключение непосредственно в самом `finally` блоке.
* Допускается использование вложенных конструкций `try/catch/finally`.

---

**Вопрос**:

Каков результат выполнения примера выше, если в блоке `try` не будет сгенерировано ни одного исключения?

**Ответ**:

Будет выведено на экран: "Hello from finally block.".

Так как блок `finally` выполняется **всегда**.

---

**Вопрос**:

Теперь немного видоизменим код, каков результат выполнения будет теперь?

```java
public class ExceptionHandling {
  public static void main(String[] args) {
    try {
         return;
    } finally {
         System.out.println("Hello from finally block");
    }
  }
}
```

**Ответ**:

На экран будет выведено: `Hello from finally block`.

---

**Вопрос**:

Плохим тоном считается прямое наследование от `java.lang.Throwable`.
Это **строго** не рекомендуется делать, почему?

**Ответ**:

Наследование от наиболее общего класса, а в данном случае от корневого класса иерархии, усложняет обработку ваших исключений. Проблему надо стараться локализовать, а не делать ее описание/объявление максимально общим. Согласитесь, что `java.lang.IllegalArgumentException` говорит гораздо больше, чем `java.lang.RuntimeException`. А значит и реакция на первое исключение будет более точная, чем на второе.

---

Далее приводится несколько примеров перехвата исключений разных видов:

Обработка `java.lang.RuntimeException`:

```java
try {
   String numberAsString = "one";
   Double res = Double.valueOf(numberAsString);
    } catch (RuntimeException re) {
            System.err.println("Error while convert string to double!");
    }
```

Результатом будет печать на экран: `Error while convert string to double!`.

Обработка `java.lang.Error`:

```java
        try {
            throw new Error();
        } catch (RuntimeException re) {
            System.out.println("RuntimeException");
        } catch (Error error) {
            System.out.println("ERROR");
        }
    }
```

Результатом будет печать на экран: `ERROR`.

#### Расположение catch блоков

Как уже было сказано, один блок `try` может иметь несколько `catch` блоков. В таком случае будет выполняться первый подходящий блок.
Это значит, что порялок расположения `catch` блоков важен.

Рассмотрим ситуацию, когда некоторый используемый нами метод может выбросить два разных исключения:

```java
void method() throws Exception {
    if (new Random((System.currentTimeMillis())).nextBoolean()) {
        throw new Exception();
    } else {
       throw new IOException();
    }
}
```

> Конструкция `new Random((System.currentTimeMillis())).nextBoolean()` генерирует нам случайное значение `false` или `true`.

Для обработки исключений этого метода написан следующий код:

```java
try {
  method();
} catch (Exception e) {
  // do some logic 1
} catch (IOException e) {
  // do some logic 2
}
```

И на первый взгляд все хорошо, однако обработка `java.lang.IOException` в данном случае недостижима.

Снова вспомним пример с Клондайком и золотодобычей.
При добыче золота, грунт смешивали с водой и прогоняли через несколько фильтров, какие-то были более узкие, какие-то более широкие.

Так вот золотинка, которую мы ищем, это и есть наше исключение, а каждый фильтр это `catch` блок.

Если первым установлен фильтр `ловить все, что является Exception и его потомков`, то до фильтра `ловить все, что является IOException и его потомков` ничего не дойдет, так как верхний фильтр уже перехватит все золотинки.

Отсюда следует правило: 

> Сначала должны идти более специальные блоки обработки исключений, а потом уже более общие.

А что если на два разных исключения предусмотрена одна и та же реакция? Написание двух одинаковых `catch` блоков не приветствуется, ведь дублирование кода - это зло.
Поэтому допускается объединить два `catch` блока с помощью `|`:

```java
try {
    method2();
} catch (IllegalArgumentException | IndexOutOfBoundsException e) {
    // do smth
}
```

---

**Вопрос**:

Есть ли способ перехватить **все** возможные исключения?

**Ответ**:

Есть! Если взглянуть еще раз на иерархию, то можно отметить, что `java.lang.Throwable` является родительским классом для всех исключений, а значит, чтобы поймать все необходимо написать что-то в виде:

```java
try {
  method();
} catch (Throwable t) {
  // catch all
}
```

Однако, делать так **не рекомендуется**, что наталкиевает на следующий вопрос.

---

**Вопрос**:

Почему перехватывать `java.lang.Throwable` плохо?

**Ответ**:

Дело в том, что написав:

```java
try {
  method();
} catch (Throwable t) {
  // catch all
}
```

Будут перехвачены абсолютно все исключения: и `java.lang.Exception`, и `java.lang.RuntimeException`, и `java.lang.Error`, и все их потомки.

И как реагировать на **все**? При этом надо учесть, что на большинство `java.lang.Error` исключений вообще не ясно как реагировать в 99% случаев. А значит, мы можем неверно отреагировать на исключение и вообще потерять данные.

Поэтому перехватывать все исключения - плохая практика.

---

**Вопрос-Тест**:

Что будет выведено на экран при запуске данного куска кода?

```java
public static void main(String[] args) {
        try {
            try {
                throw new Exception("0");
            } finally {
                if (true) {
                    throw new IOException("1");
                }

                System.err.println("2");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("3");
            System.err.println(ex.getMessage());
        }
    }
```

**Ответ**:

При выполнении данного кода выведется "1".
Давайте разберем почему.

Мы кидаем исключение во вложенном `try` блоке: `throw new Exception("0");`.

После этого поток программы ломается и мы попадаем в `finally` блок:

```java
if (true) {
    throw new IOException("1");
}

System.err.println("2");
```

Здесь мы гарантированно зайдем в `if` и кинем уже новое исключение: `throw new IOException("1");`.

> При этом вся информация о прошлом будет потеряна! Ведь мы никак не отреагировали на него, а в `finally` блоке и вовсе 'перезатерли' новым исключением.

На `try`, оборачивающий наш код, настроено два фильтра: первый на `IOException`, второй на `Exception`.

Так как порядок расположения задан так, что мы прежде всего смотрим на `IOException`, то и сработает этот фильтр, который выполнит следующий код:

```java
System.err.println(ex.getMessage());
```

Именно поэтому выведется `1`.

---

#### Транзакционность

Важным моментом, который нельзя пропустить, является то, что `try` блок **не транзакционный**.

> Под термином `транзакционность` я имею в виду то, что либо действия будут выполнены целиком и успешно, либо не будут выполнены вовсе.

Что это значит?
Это значит, что при возникновении исключения в `try` блоке все совершенные действия **не** откатываются к изначальному состоянию, а так и остаются совершенными.
Все выделенные ресурсы так и остаются занятыми, в том числе и при возникновении исключения.

По сути именно поэтому и существует `finally`-блок, так как туда, как уже было сказано выше, мы зайдем **в любом** случае, то там и освобождают выделенные ресурсы.

---

**Вопрос**:

Работа с объектами из `try` блока в других блоках невозможна:

```java
public class ExceptionExample {
    public static void main(String[] args) {
        try {
            String line = "hello";
        } catch (Exception e) {
            System.err.println(e);
        }

        // Compile error
        System.out.println(line); // Cannot resolve symbol `line`
    }
}
```

Почему?

**Ответ**:

Потому что компилятор не может нам гарантировать, что объекты, объявленные в `try`-блоке, были созданы.

Ведь могло быть сгенерировано исключение. Тогда после места, где было сгенерировано исключение, оставшиеся действия не будут выполнены, а значит возможна ситуация, когда объект не будет создан. Следовательно и работать с ним нельзя.

---

Вернемся к примеру с грузовиком, чтобы объяснить все вышесказанное.

![Объездная](../images/exception/exception_ob.png)

Объездная здесь - это `catch` блок, реакция на исключительную ситуацию. Если добавить еще несколько объездных дорог, несколько `catch` блоков, то водитель выберет наиболее подходящий путь, наиболее подходящий и удобный `catch` блок, что объясняет важность расположения этих блоков. Транзакционность на этом примере объясняется тем, что если до этого водитель где-то оплатил проезд по мосту, то деньги ему автоматически не вернутся, необходимо будет написать в поддержку или куда-то пожаловаться на управляющую компанию.

### Делегирование

Выше было разобрано то, как обрабатывать исключения. Однако, иногда возникают ситуации, когда в нет конкретного понимания на то, как обрабатывать возникшее исключение. В таком случае имеет смысл делегировать задачу обработки исключения коду, который вызвал ваш метод, так как вызывающий код чаще всего обладает более обширными сведениями об источнике проблемы или о бизнес-операции, которая сейчас выполняется.

Делегирование исключения производится с помощью ключевого слова `throws`, которое добавляется после сигнатуры метода.

Пример:

```java
// Код написан только для ознакомительной цели, не стоит с него брать пример!
String readLine(String path) throws IOException {
    BufferedReader br = new BufferedReader(...);
    String line = br.readLine();

    return line;
}
```

Таким образом обеспечивается передача объявленного исключения в место вызова метода. И то, **как** на него реагировать уже становится заботой вызывающего этот метод.
Поэтому реагировать и писать обработчики на те исключения, которые мы делегировали, внутри метода уже не надо.

Механизм `throws` введен для проброса проверяемых исключений.

Разумеется, можно с помощью `trhows` можно описывать делегирование как проверяемых, так и непроверяемых исключений.
Однако перечислять непроверяемые не стоит, такие исключения не контролируются в `compile time`. Перечисление непроверяемых исключений бессмысленно, так как это примерно то же самое, что перечислять все, что может с вами случиться на улице.

Теперь пришла пора рассмотреть методы обработки исключительных ситуаций.

### Методы и практики обработки исключительных ситуаций

Главное и основное правило при работе с исключениями звучит так:

> На исключения надо либо **реагировать**, либо **делегировать**, но ни в коем случае не **игнорировать**.

Определить когда надо реагировать, а когда делегировать проще простого. Задайте вопрос: "Знаю ли я как реагировать на это исключение?".
Если ответ "да, знаю", то реагируйте, пишите обработчик и код, отвечающий за эту реакцию, если не знаете что делать с исключением, то **делегируйте** вызывающему коду.

#### Собственные исключения

Выше мы уже затронули то, что исключения это те же классы и объекты.
И иногда удобно выстроить свою иерархию исключений, заточенных под конкретную задачу. Дабы более гибко обрабатывать и реагировать на те исключительные ситуации, которые специфичны решаемой задаче.

Например, пусть есть некоторый справочник:

```java
class Catalog {
    Person findPerson(String name);
}
```

В данном случае нам надо обработать ситуации, когда `name` является `null`, когда в каталоге нет пользователя с таким именем.

Если генерировать на все ситуации `java.lang.Exception`, то обработка ошибок будет крайне неудобной.
Более того, хотелось бы явно выделить ошибку, связанную с тем, что пользователя такого не существует.
Очевидно, что стандартное исключение для этого случая не существует, а значит вполне логично создать свое.

```java
class PersonNotFoundException extends RuntimeException {
    private String name;

    // some code
}
```

Обратите внимание, что имя `Person`, по которому в каталоге не смогли его найти, выделено в свойство класса.

Теперь при использовании этого метода проще реагировать на различные ситуации, такие как `null` вместо имени, а проблему с отсутствием `Person` в каталоге можно отдельно вынести в свой `catch` блок.

#### Реагирование через re-throw

Часто бывает необходимо перехватить исключение, сделать запись о том, что случилось(в файл лога, например) и делегировать его вызывающему коду.
Как уже было сказано выше, в рамках конструкции `try/catch/finally` возможно повторно сгенерировать исключение.

Такой подход называется `re-throw`.

Исключение перехватывается в `catch` блоке, совершаются необходимые действия, например, запись в лог или создание нового, более конкретного для контекста задачи, исключения и повторная генерация исключения.

Как это выглядит на практике:

```java
try {
    Reader readerConf = ....
    readerConf.readConfig();
} catch(IOException ex) {
    System.err.println("Log exception: " + ex);
    throw new ConfigException(ex);
}
```

Во время чтения конфигурационного файла произошло исключение `java.lang.IOException`, в `catch` блоке оно было перехвачено, сделана запись в консоль о проблеме, после чего было создано новое, более конкретное, исключение `ConfigException`, с указанием причины(перехваченное исключение, ссылка на которое `ex`) и оно было проброшено дальше.

По итогу, из метода с приведенным кодом, в случае ошибки чтения конфигурации, будет выброшено `ConfigException`.

Для чего мы здесь так поступили?

Это полезно для более гибкой обработки исключений.
В примере выше чтение конфигурации генерирует слишком общее исключение, так как `java.lang.IOException` это довольно общее исключение, но проблема в примере выше понятна: работа с этим конфигурационным файлом невозможна.

Значит и сообщить лучше именно как о том, что это не абстрактный `java.lang.IOException`, а именно `ConfigException`. При этом, так как перехваченное исключение было передано новому в конструкторе, т.е указалась причина возникновения `ConfigException`, то при выводе на консоль или обработке в вызывающем коде будет понятно почему `ConfigException` был создан.
Также, можно было добавить еще и текстовое описание к сгенерированному `ConfigException`, более подробно описывающее произошедшую ситуацию.

Еще одной важной областью применения `re-throw` бывает преобразование проверяемых исключений в непроверяемые.
В `Java 8` даже добавили исключение `java.io.UncheckedIOException`, которое предназначено как раз для того, чтобы сделать `java.lang.IOException` непроверяемым, обернуть в `unchecked` обертку.

Пример:

```java
try {
    Reader readerConf = ....
    readerConf.readConfig();
} catch(IOException ex) {
    System.err.println("Log exception: " + ex);
    throw new UncheckedIOException(ex);
}
```

#### Чего нельзя делать при обработке исключений

* Старайтесь не игнорировать исключения.
  
  В частности, никогда не пишите подобный код:

    ```java
    try {
        Reader readerConf = ....
        readerConf.readConfig();
    } catch(IOException e) {
        e.printStackTrace();
    }
    ```

* Не следует писать 'универсальные' блоки обработки исключений, ведь очень трудно представить себе метод, который одинаково реагировал бы на все возникающие проблемы.
  
  Также программный код может измениться, а 'универсальный' обработчик исключений будет продолжать обрабатывать новые типы исключений одинаково. Поэтому таких ситуаций лучше не допускать.
* Старайтесь не преобразовывать более конкретные исключения в более общие. В частности, например, не следует `java.lang.IOException` преобразовывать в `java.lang.Exception` или в `java.lang.Throwable`.
  Чем с более конкретными исключениями идет работа, тем проще реагировать и принимать решения об их обработке.
* Старайтесь не злоупотреблять исключениями. Если исключение можно недопустить, например, дополнительной проверкой, то лучше так и сделать.
  
  Например, можно обезопасить себя от `java.lang.NullPointerException` простой проверкой:

  ```java
  if(ref != null) {
      // some code
  }
  ```

### Try-with-resources или try-с-ресурсами

Как уже говорилось выше про `finally` блок, код в нем выполняется в любом случае, что делает его отличным кандидатом на место по освобождению ресурсов, учитывая не транзакционность блока `try`.

Чаще всего за закрытие ресурса будет отвечать код, наподобие этого:

```java
try {
    // code
} finally {
    resource.close();
}
```

Освобождение ресурса(например, освобождение файлового дескриптора) это поведение.

> А за поведение у нас отвечают [интерфейсы](../oop/interface.md).

Это наталкивает на мысль, что нужен некоторый общий интерфейс, который бы реализовывали все классы, для которых необхожимо выполнить какой-то код по освобожлдению ресурсов, т.е выполнить 'закрытие' в `finally` блоке и еще удобнее, если бы этот однообразный `finally` блок не нужно было писать каждый раз.
Поэтому, начиная с `Java 7`, была введена конструкция `try-with-resources` или `TWR`.

Для этого объявили специальный интерфейс `java.lang.AutoCloseable`, у которого один метод:

```java
void close() throws Exception;
```

Все классы, которые будут использоваться так, как было описано выше, должны реализовать или `java.lang.Closable`, или `java.lang.AutoCloseable`.

В качестве примера, напишем код чтения содержимого файла и представим две реализации этой задачи: используя и не используя `try-with-resources`.

Без использования `try-with-resources`(пример ниже плох и служит только для демонстрации объема необходимого кода):

```java
BufferedReader br = null;
try {
       br = new BufferedReader(new FileReader(path));
       // read from file
   } catch (IOException e) {
       // catch and do smth
   } finally {
           try {
                  if (br != null) {
                     br.close();
                  }
               } catch (IOException ex) {
                     // catch and do smth
               }
   }
```

А теперь то же самое, но в `Java 7+`:

```java
try (FileReader fr = new FileReader(path);
    BufferedReader br = new BufferedReader(fr)) {
         // read from file
} catch (IOException e) {
         // catch and do smth
}
```

По возможности пользуйтесь **только** `try-with-resources`.

> Помните, что, без реализации `java.lang.Closable` или `java.lang.AutoCloseable` ваш класс не будет работать с `try-with-resources` так, как показано выше.

---

**Вопрос**:

Получается, что используя `TWR` мы не пишем закрытие код для закрытия ресурсов, но при их закрытии может же тоже быть исключение! Что произойдет?

**Ответ**:

Точно также, как и без `TWR`, исключение выбросится так, будто оно было в `finally`-блоке.

Помните, что `TWR`, грубо говоря, просто добавляет вам блок кода вида:

```java
finally {
    resource.close();
}
```

---

## Исключения и статические блоки

Еще интересно поговорить про то, что происходит, если исключение возникает в статическом блоке.

Так вот, такие исключения оборачиваются в `java.lang.ExceptionInInitializerError`:

```java
public class ExceptionHandling {
    static {
        throwRuntimeException();
    }

    private static void throwRuntimeException()  {
        throw new NullPointerException();
    }

    public static void main(String[] args)  {
        System.out.println("Hello World");
    }
}
```

Результатом будет падение со следующим стектрейсом:

```java
java.lang.ExceptionInInitializerError Caused by: java.lang.NullPointerException at exception.test.ExceptionHandling.throwRuntimeException(ExceptionHandling.java:13) at exception.test.ExceptionHandling. (ExceptionHandling.java:8)
```

## Многопоточность и исключения

Что будет, если исключение возникнет в отдельном потоке исполнения?

Например:

```java
public class ExceptionHandling4 {
  public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread() {
        @Override
        public void run() {
                throw new RuntimeException("Testing unhandled exception processing.");
         }
    };
    t.start();
  }
}
```

Результатом выполнения этого кода будет то, что возникшее исключение прервет поток исполнения(interrupt thread):

```java
Exception in thread “Thread-0” java.lang.RuntimeException: Testing unhandled exception processing. at exception.test. ExceptionHandling4$1.run(ExceptionHandling4.java:27)
```

В таких ситуациях рекомендуется использовать `Thread.UncaughtExceptionHandler`.
Т.е вешать отдельный `handler` на поток, который будет обрабатывать возникшие в нем исключения.

```java
t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
          public void uncaughtException(Thread t, Throwable e)   {
             System.out.println("Handled uncaught exception in thread :" + t + " Exception : " + e);
         }
  });
```

И вывод уже будет:

```java
Handled uncaught exception in thread :Thread[Thread-0,5,main] Exception : java.lang.RuntimeException: Testing unhandled exception processing.
```

## Заключение

Механизм исключений сложен, но крайне важен для понимания. 
Исключения делятся на два вида: `unchecked` и `checked`. Проверяемые исключения - это искючения, которые проверяются на этапе компиляции, мы **обязаны** на них отреагировать.

Проверяемые исключения в `Java` используются тогда, когда разработчик никак не может предотвратить их возникновение. Причину возникновения `java.lang.RuntimeException` можно проверить и устранить заранее, например, проверить ссылку на `null` перед вызовом метода, на объекте по ссылке. А вот с причинами проверяемых исключений так сделать не получится, так как ошибка при чтении файла может возникнуть непосредственно в момент чтения, потому что другая программа его удалила. Соответственно, при чтении файла требуется обрабатывать `java.lang.IOException`, который является потомком `java.lang.Exception`.

Допускается создание собственных исключений, признак проверяемости или непроверяемости наследуется от родителя. Исключения - это такие же классы, со своим поведением и состоянием, поэтому при наследовании вполне допускается добавить дополнительное поведение или свойства классу.

Помните, что `try` блок **не транзакционен**, все ресурсы, занятые в `try` **ДО** исключения остаются в памяти. Их надо освобождать и очищать вручную.
Если вы используете `Java` версии 7 и выше, то отдавайте предпочтение конструкции `try`-с-ресурсами.

Основное правило:

> На исключения можно реагировать, их обработку можно делегировать, но ни в коем случае нельзя их игнорировать.

Определить когда надо реагировать, а когда делегировать проще простого. Задайте вопрос: "Знаю ли я как реагировать на это исключение?".
Если ответ "да, знаю", то реагируйте, пишите обработчик и код, отвечающий за эту реакцию, если не знаете что делать с исключением, то **делегируйте** вызывающему коду.

Помните, что исключения ломают поток выполнения программы, поэтому чем раньше вы обработаете возникшую проблему, тем лучше. Отсюда же следует совет, что лучше не разбрасываться исключениями, так как помимо того, что это ломает поток выполнения, это еще и дорогостоящая операция.

Постарайтесь не создавать 'универсальных' обработчиков, так как это чревато трудноуловимыми ошибками.

Если исключение можно не генерировать, то лучше так и сделать. Не пренебрегайте проверками.

Старайтесь продумывать то, как вы будете реагировать на исключения, не игнорировать их, использовать **только** `try-с-ресурсами`.

## Полезные ссылки

1. [Книга С. Стелтинг 'Java без сбоев: обработка исключений, тестирование, отладка'](https://www.ozon.ru/context/detail/id/2342758/)
2. [Oracle Java Tutorials](https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html)
3. [Лекция Технострим Исключения](https://www.youtube.com/watch?v=zRRopPImRqA)
4. [Лекция OTUS Исключения в Java](https://www.youtube.com/watch?v=nP-yT6tmbGs)
5. [Заметка Евгения Матюшкина про Исключения](http://www.skipy.ru/technics/exceptions.html)
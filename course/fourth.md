# Java Базовый Курс

## Занятие 4

Четвертое занятие в рамках `Java` курса.

В [прошлый раз](./third.md) мы затронули следующие темы:

* Интерфейсы
* Абстрактные классы
* Различия между ними, когда что применять

В рамках этого занятия мы обсудим такую тему как коллекции в `Java`. Какие коллекции существуют в `Java`, какие операции с ними возможны, когда что использовать и т.д.

## Введение

В начале проведем некоторую проверку знаний по прошлому материалу.

---

**Вопрос**:

Может ли абстрактный класс быть `final`?

**Ответ**:

Нет, не может.

Ключевое слово `final` означает, что класс на вершине иерархии, у него не может быть наследников.
Абстрактный класс без наследников не имеет никакого смысла.

---

**Вопрос**:

Может ли быть абстрактный класс без абстрактных методов?

**Ответ**:

Да, может.

---

**Вопрос**:

Что такое интерфейс-маркер?

**Ответ**:

Интерфейс может быть пустым - не содержать никаких объявлений, как в примере выше.
Такие интерфейсы называются `интерфейсы-маркеры`.

В качестве примера можно посмотреть такие интерфейсы как `java.io.Serializable`, `java.lang.Cloneable` и `java.util.EventListener`.

Как следует из названия, задача интерфейса-маркера сообщить о наличии определённого поведения у объектов класса, помеченного таким интерфейсом.

---

Коллекции в `Java` - это динамические структуры данных для хранения объектов. Для того, чтобы понять в чем разница между обычным массивом и колллекцией, давайте вспомним, какие ограничения задаются обычным массивом?

Предположим, вам нужен массив строк, в котором планируется хранить `10` элементов:

```java
String[] array = new String[10];
```

Вас все устраивает до тех пор, пока не понадобится добавить 11-й элемент в такой массив.
В таком случае, если вам все нужно увеличить количество элементов в массиве, у вас есть только два выхода:

* Создать новый массив, большего размера, и итеративно перенести объекты из старого массива в новый.
* Воспользоваться специальным методом для копирования элементов(об этом чуть позже).

Каждый раз думать о таком копировании и увеличении размера крайне неудобно, гораздо лучше, если бы эта задача была возложена не на ваши плечи, правда?
Вот тут-то и выходят на сцену коллекции!

Коллекции появились в `Java 1.2`. И теперь нет необходимости заботиться о том, какого размера у вас массив, сколько объектов у вас сейчас в нем находится, бояться получить ошибку переполнения массива при добавлении нового элемента и т.д.

Иерархия существующих коллекций `Java` выглядит следующим образом:

<img src="../images/collections/collections.png">

Как видно, в `Java` существует несколько реализаций, каждая из них выполняет свою функцию и отвечает разным требованиям, которые ставятся перед разработчиком.

Коллекции делятся на два категории:

* Динамические массивы(все, что реализует `Iterable` и `Collection`)
* Ключ-значение(все, что реализует `Map`)

Разберем левую часть, которая реализует интерфейс `java.util.Collection`.

## java.util.Collection

Интерфейс `java.util.Collection` предоставляет основные методы работы с коллекциями в `Java`. Он является корневым интерфейсом для всех реализаций, поэтому методы, объявленные в нем присутствуют у каждой реализации коллекции.

Взглянем на основные методы:

* `boolean add(element)`
* `boolean remove(element)`
* `int size()`
* `boolean isEmpty()`
* `boolean contains(element)`
* `void clear()`

Разумеется, присутствуют методы, для добавления к коллекции не только одного элемента, а целого коллекции элементов, также как и удаления, существует возможность удалять по предикату(некоторому условию), но перечислены наиболее часто используемые.

Интересно рассмотреть `boolean add(element)`, который, при добавлении элемента в коллекцию вернет `true`, если коллекция была изменена в результате добавления. Если же текущая реализация коллекции не может содержать дубликаты и уже содержит добавляемый элемент будет возвращено значение `false`.

Еще одним интересным моментом является то, что интерфейс `java.util.Collection` **не предоставляет** метода, который достает элемент из коллекции.

Т.е интерфейс `java.util.Collection` предоставляет возможность только добавлять и удалять значения из коллекции, но не извлекать.

> Сделано это потому, что не все коллекции являются упорядоченными, поэтому извлечь по индексу элемент нельзя.

---

### Интерфейс java.util.List

Как уже было сказано во [введении](../intro.md), интерфес `java.util.List` расширяет `java.util.Collection`, добавляя туда новые методы.

Как и все интерфейсы в иерархии коллекций, `java.util.List` параметризуется.

Объявление `java.util.List` выглядит как:

```java
public interface List<E> extends Collection<E> {
    // ...
}
```

Иногда реализации `java.util.List` называют списками или последовательностями.

Реализации `java.util.List` являются упорядоченными структурами данных, разрешающими дубликаты.

Основные методы, которые добавляет интерфейс `java.util.List`:

* `E get(int index)`
* `void add(int index, E element)`
* `int indexOf(Object element)`
* `E remove(int index)`

Интерфейс позволяет доставать элементы списка по индексу(позиции в списке), добавлять элемент по определенному индексу и узнавать индекс элемента.

Другими словами, реализации `java.util.List` предоставляют пользователю контроль над позицией элемента в списке.

Нумерация индексов, как и у массивов, начинается с `0`.

Более конкретно про `java.util.ArrayList` смотрите по ссылке [тут](../collections/list/intro.md)

---

#### java.util.ArrayList

Класс `java.util.ArrayList` является одной из самых популярных и часто используемых реализаций интерфейса `java.util.List`.

Данная реализация основана на массиве, но, в отличии от массивов в `Java`, `java.util.ArrayList` может динамически менять размер, а также хранить `null` значения.

Прежде всего обратим внимание на поля класса:

```java
    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * The array buffer into which the elements of the ArrayList are stored.
     * The capacity of the ArrayList is the length of this array buffer. Any
     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * will be expanded to DEFAULT_CAPACITY when the first element is added.
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * The size of the ArrayList (the number of elements it contains).
     *
     * @serial
     */
    private int size;
```

Количество элементов в списке хранится в переменной `size`.

Важно понимать, что `size` - это не размер массива, это именно количество элементов.

> Если представить массив как шкаф с ящиками, то размер массива - это количество ящиков, а количество элементов массива - это количество занятых ящиков.

Как было сказано выше, в основе реализации лежит массив.

За это отвечает поле `elementData`.

Массив имеет фиксированный размер, а значит при создании списка его надо как-то инициализировать.

Если не указать размер массива при создании объекта `java.util.ArrayList` будет создан массив размером `10`. Но создан он будет только при добавлении первого элемента. То есть при создании нового объекта типа `java.util.ArrayList`, создается новый пустой массив.

А уже при первом обращении к методу add создается новый массив размера 10. В случае создания нового `java.util.ArrayList` с указанным начальным размером массива, сам массив будет создан при создании объекта, а не при первом обращении к методу add.

Это значение по-умолчанию, которое хранится в константе `DEFAULT_CAPACITY`.

Можно указать размер при создании объекта списка воспользовавшись конструктором и передав туда значение желаемого размера:

```java
public ArrayList(int initialCapacity) {
    // ...
}
```

ArrayList реализует интерфейс `java.util.List`, который, в свою очередь, является наследником интерфейса `java.util.Collection`. Поэтому они реализует основные

метод, которые есть в `java.util.Collection`, о которых было сказано выше.

Рассмотрим основные методы:

За добавление элемента в конец у `java.util.ArrayList` отвечает метод:

```java
    /**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return <tt>true</tt> (as specified by {@link Collection#add})
     */
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
```

Перед тем, как вставить добавляемый элемент в список происходит проверка: достаточно ли места для вставки?

За это отвечает метод `ensureCapacityInternal`.

Т.е сначала проверяется хватает ли места для добавления нового элемента и если хватает, то происходит добавление элемента в конец, при этом возвращается `true`, так как список изменяется.

Для достижения динамичности расширения максимального количества элементов в ArrayList используется алгоритм проверки вместимости текущего массива.

Рассмотрим такой пример: создадим новый объект `List list = new ArrayList()`. Так как мы явно не указали при создании объекта начальное значение размера массива, который содержит в себе ArrayList,

то будет создан массив размера 10. Предположим, что в наш объект list было добавлено 10 объектов, и мы добавляем 11ый. Тогда при добавлении 11го элемента через метод add(E e), произойдет следующее:

* При вызове метода add внутри него идет проверка вместимости массива с помощью ensureCapacityInternal(size + 1)
* Если массив уже полон, то сначала вычисляется новый размер массива с помощью побитового сдвига вида:

```java
int newCapacity = oldCapacity + (oldCapacity >> 1)
```

где oldCapacity - это текущий размер массива.

* Создается новый массив, размер которого равен `newCapacity`

* Вызывается `native`- метод `System.arrayCopy`, который переносит объекты из старого массив в новый

Чтобы получить объект из нашего списка, нужно вызвать метод get(int index). Так как `java.util.ArrayList` по сути своей обертка над массивом, в методе `get` идет простое обращение к массиву внутри `ArrayList`. Но перед этим этот метод проверяет,

не пытаетесь ли вы обратиться к индексу, который больше значения поля size, о котором говорилось выше. Если же значение переданного вами индекса все же больше, то метод `get` вернет ошибку IndexOutOfBoundsException с сообщение такого вида "Index: "+index+", Size: "+size", где

`index` - это индекс элемента, который вы запрашиваете из вашего списка, а `size` - это текущее количество элементов в списке.

Таким образом, реализация `java.util.ArrayList` из стандартной библиотеки `Java` предоставляет быстрый доступ к элементам по индексу и линейное время доступа к элементам по значению.

Благодаря использованию `native`- метода `System.arrayCopy` реализация `java.util.ArrayList` является предпочтительным выбором при необходимости использования списка.

> Ключевое слово `native` означает, что метод реализован в платформенно-зависимом коде, чаще всего на `C/C++`, и скомпонован в виде динамической библиотеки.
>
> Эта реализация зависит от `JVM`.

Данная реализация позволяет хранить любые значения, в том числе дубликаты и `null`.

Более конкретно про [java.util.ArrayList](../collections/list/array_list.md)

---

#### java.util.LinkedList

Класс `java.util.LinkedList` является второй, после `java.util.ArrayList`, популярной реализацией интерфейса `java.util.List`.

Данная реализация основана на двусвязном списке, каждый элемент содержит ссылку на следующий и предыдущий элементы.

Реализация полностю написана на `Java` и не использует никаких `native` методов.

> Ключевое слово `native` означает, что метод реализован в платформенно-зависимом коде, чаще всего на `C/C++`, и скомпонован в виде динамической библиотеки.
>
> Эта реализация зависит от `JVM`.

Позволяет хранить любые значения, в том числе и `null` значения.

Прежде всего обратим внимание на поля класса и выделим наиболее значимые:

```java
    transient int size = 0;

    /**
     * Pointer to first node.
     * Invariant: (first == null && last == null) ||
     *            (first.prev == null && first.item != null)
     */
    transient Node<E> first;

    /**
     * Pointer to last node.
     * Invariant: (first == null && last == null) ||
     *            (last.next == null && last.item != null)
     */
    transient Node<E> last;

    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

В классе `java.util.LinkedList` объявляется вложенный класс `Node`.

Класс `Node` является оберткой, в которую 'заворачиваются' все добавляемые элементы, он необходим для того, чтобы объявить ссылки на близлежащие элементы списка.

Представьте себе цепь, каждое звено которой сцеплено с предыдущим и следующим звеном. Так вот каждое звено - это и есть объект класса `Node`.

Проиллюстрируем это:

![Двусвязный список](/images/collections/linked_list_example.png)

Количество элементов в списке хранится в переменной `size`, точно также как и в `java.util.ArrayList`.

Класс `java.util.LinkedList` хранит ссылку на первый и последний элемент списка. Благодрая чему осуществляется быстрая вставка в начало и в конец.

Более конкретно про [java.util.LinkedList](../collections/list/linked_list.md)
